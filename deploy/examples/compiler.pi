//include('lib/pimii.pi');
//include('lib/stack.pi');

makeStack := initialValue -> #(initialValue);

popStack := stack -> {
   [h|t := head(stack) : setHead(stack, t); ^h ];
   ^nil;
};

pushStack := (stack, value) -> {
   setHead(stack, #(value) & head(head(stack)));
};

peekStack ::= head;



detectTokenType := c -> {
  [ isLetter(c) : ^#IDENT ]
  [ isDigit(c) : ^#NUMBER ]
  [ isWhitespace(c) : ^#SEEK ]
  [ c = '(' : ^#L ]
  [ c = '"' : ^#STRING ]
  [ c = ')' : ^#R ]
  [ c = '+' : ^#ADD ]
  [ c = '-' : ^#SUB ]
  [ c = '*' : ^#MUL ]
  [ c = '/' : ^#DIV ]
  [ c = '=' : ^#EQ ]
  [ c = '!' : ^#NOT ]
  [ c = '$' : ^#quote ]
  ^#SPECIAL
};

initToken := (mode, c) -> {
  [ mode = #STRING : ^'' ]
  ^c
};

convert := (mode, c) -> {
  [ mode = #NUMBER : ^parse(c) ]
  [ mode = #IDENT :  ^asSymbol(c) ]
  [ mode = #STRING :  ^c ]
  ^mode
}


tokenize := s -> {

   mode := #SEEK;
   result := makeStack(#());
   token := '';

   output := {
      [ mode = #L : log(#L); log(peekStack(result)); log(result); ^pushStack(result, #()) ]
      [ mode = #R :
         sublist := popStack(result);
log(#R);
log(peekStack(result));
log(sublist);
         ^pushStack(result, popStack(result) & sublist);
      ] 
      [ mode != #SEEK : ^pushStack(result, popStack(result) & convert(mode, token)) ]
   };

   eachChar: s do: c -> {
     [ mode = #STRING && '"' != c : ^token := token + c ]
     [ mode = #STRING && '"' = c : output(); ^mode := #SEEK ]
     [ mode = #IDENT && isLetter(c) : ^token := token + c]
     [ mode = #NUMBER && isDigit(c) : ^token := token + c ]
        output();
        mode := detectTokenType(c);
        ^token := initToken(mode, c);
     
   };
   output();
   popStack(result);
}


getStack := stack -> head(stack);

comp := code -> {
   bytecode := #();
   
   compileList := #();

   knownSymbols := makeStack(#());

   lookup := symbol -> {
      find := (offset, list) -> {
         [ isNil(list) : ^makePair(1 , 1) ]
         [ indexOf(symbol, head(list)) > 0 : ^makePair(offset , indexOf(symbol, head(list)))]
         ^find(offset + 1, tail(list))
      };

      find(0, getStack(knownSymbols));
   }

   compileAtom := code -> {
      [ isList(code) : ^compileList(code)]
      [ isSymbol(code) : ^bytecode := bytecode & #LD & lookup(code) ]
      [ isString(code) : ^bytecode := bytecode & #LDC & code]
      [ isNumber(code) : ^bytecode := bytecode & #LDC & code]
   };   

   isPrimitive := h -> h = #ADD || h = #SUB || h = #MUL || h = #DIV || h = #EQ || h = #NOT;

   compileList := list -> {
      [ head(list) = #lambda : 
         pushStack(knownSymbols, at(list, 2));
         buffer := bytecode;
         bytecode := #();
         compileList(at(list, 3));
         popStack(knownSymbols);
         ^bytecode := buffer & #LDF & (bytecode & #RET); 
      ]
      [ head(list) = #if : ^#false ]
      [ head(list) = #quote: ^bytecode := bytecode & #LDC & tail(list); ]
      [ isPrimitive(head(list)) : each: tail(list) do: sub -> compileAtom(sub);
            ^bytecode := bytecode & head(list); ]
      [ head(list) = #let : 
            symbols := project: at(list, 2) with: p -> head(p);
            pushStack(knownSymbols, symbols);
            buffer := bytecode;
            bytecode := #();
            compileList(at(list, 3));
            popStack(knownSymbols);
            bytecode := buffer & #LDF & (bytecode & #RET); 
            
            args := tail(list, 2);
            bytecode := bytecode & #NIL;
            each: args do: arg -> {
               compileAtom(at(arg, 2));
               bytecode := bytecode & #CONS;
            }
            ^bytecode := bytecode & #AP;
      ]
      compileAtom(head(list));
      args := tail(list);
      bytecode := bytecode & #NIL;
log(#args);
log(args);
      each: reverse(args) do: arg -> {
log(arg);
         compileAtom(arg);
         bytecode := bytecode & #CONS;
      }
      ^bytecode := bytecode & #AP;
   }

   compileAtom(code);
}

makePair := #(#(#LD #(1 . 2) #LD #(1 . 1) #CONS #RTN));


reverse ::= list -> {
    fold: list with: (e, l) -> makePair(e, l) start: #()
}

//s := '(lambda (x y) (* x y)) 1 2';
s := 'let ((x 2) (y 2)) (* x y)';
c := tokenize(s);
log(c);
comp(c);


