each:do: ::= (list, block) -> {
    [h|t := list : block(h); each: t do: block]
};

fold:with:start: ::= (list, block, sum) -> {
    [h|t := list : fold: t with: block start: block(h, sum)]
    [            : sum ]
};

length ::= list -> [
    fold: list with: [e, sum -> sum + 1] start: 0
];

reverse ::= list -> [
    fold: list with: [e, l -> e & l ] start: #()
];

collect:with: ::= (list, filter) -> [
    result := fold: list
              with: (e,l) -> {
                        [filter(e) : e & l]
                        [          : l]
                    }
              start: #();

    reverse(result);
];

reject:with ::= (list, filter) -> [
    collect: list with: [ e -> !filter(e)]
];

project:with: ::= (list, mapping) -> [
    result := fold: list with: [e,l -> mapping(e) & l] start: #();
    reverse(result);
];

